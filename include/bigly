/*
 * bigly - library for arbitrarily large numbers
 *
 * Copyright (C) 2023 Garyl Hester. All rights reserved.
 * 
 * This project lives at https://github.com/codefool/bigly
 *
 */
#pragma once

#include <iostream>
#include <cstring>
#include <cctype>
#include <iterator>
#include <memory>
#include <string>
#include <vector>

#include "buildinfo.h"

namespace cflib {

class bigly {
public:
    enum sign_t : bool {
        POS = false,
        NEG = true
    };
    typedef signed char          digit_t;
    const size_t BLOCK_SIZE = 1024;

private:
    sign_t   _sign;   // sign - true negative, false positive
    size_t   _len;    // no. digits used in m
    size_t   _frac;   // no. of fractional digits
    size_t   _blkcnt; // block count
    size_t   _size;   // size of m
    digit_t *_m;      // buffer with mantissa

public:
    bigly();
    bigly(const bigly& o);
    bigly(std::string num);
    bigly(const int64_t val);
    bigly(const int64_t mant, const int64_t frac);
    virtual ~bigly();

    //   +-- end
    //   +-- mend
    //   |  +-- mbegin
    //   |  +-- d
    //   1234.5678
    //        |  +-- begin
    //        |  +-- fbegin
    //        +-- fend  

    const signed char *begin()  const { return _m; }
    const signed char *end()    const { return _m + _len - 1; }
    const signed char *mbegin() const { return _m + _frac; }
    const signed char *mend()   const { return end(); }
    const signed char *fbegin() const { return begin(); }
    const signed char *fend()   const { return _m + _frac - 1; }

    size_t mant() const { return _len - _frac; }
    size_t frac() const { return _frac; }

    bool is_zero() {
        return _len == 0;
    }

    inline int sign() const {
        return _sign ? -1 : 1;
    }

    bigly abs() const {
        bigly ret(*this);
        ret._sign = POS;
        return ret;
    }

    bigly negate() const {
        auto ret(*this);
        ret._sign = (sign_t)(!_sign);
        return ret;
    }

    void set_sign(sign_t s) {
        _sign = s;
    }

    bool is_negative() const {
        return _sign;
    }

    bool is_positive() const {
        return !_sign;
    }

    // answer -1 if lhs < rhs, 0 if lhs == rhs, and 1 if lhs > rhs
    int compare(const bigly& rhs) const;

    inline bool operator==(const bigly& rhs) const {
        return compare(rhs) == 0;
    }

    inline bool operator<(const bigly& rhs) const {
        return compare(rhs) < 0;
    }

    inline bool operator<=(const bigly& rhs) const {
        return compare(rhs) <= 0;
    }

    inline bool operator>(const bigly& rhs) const {
        return compare(rhs) > 0;
    }

    inline bool operator>=(const bigly& rhs) const {
        return compare(rhs) >= 0;
    }

    inline digit_t& operator[](size_t index) {
        return _m[index];
    }

    bigly& operator=(const bigly& o);

    bigly& operator++();
    bigly operator++(int);
    bigly& operator--();
    bigly operator--(int);

    bigly operator+(const bigly& rhs) const;
    bigly& operator+=(const bigly& rhs);

    bigly operator-(const bigly& rhs) const;
    bigly& operator-=(const bigly& rhs);

    bigly operator*(const bigly& rhs) const;
    bigly& operator*=(const bigly&rhs);
    bigly operator^(const bigly& rhs) const;
    bigly& operator^=(const bigly&rhs);

    bigly operator%(const bigly& rhs) const;
    bigly& operator%=(const bigly& rhs);
    bigly operator/(const bigly& rhs) const;
    bigly& operator/=(const bigly& rhs);

    bigly add(const bigly& rhs) const;
    bigly sub_method_one(const bigly&rhs) const;
    bigly sub_method_two(const bigly& rhs) const;
    bigly sub_method_diff_magn(const bigly& rhs) const;
    bigly nines_complement(const size_t len) const;
    bigly int_division(const bigly& rhs, bigly& rem) const;

    bigly& strip_leading(digit_t dig = 0);

    friend std::ostream& operator<<(std::ostream& os, const bigly& obj);

    static bigly factorial(size_t n);
    static bigly fibonacci(size_t n);

public: //FIXME: protected
    void resize();

    void insert(size_t where, digit_t what);

    void minsert(signed char what) {
        insert(_frac, what);
    }

    void finsert(signed char what) {
        insert(0, what);
        _frac++;
    }

    // insert digit to front of mantissa
    void mpush_front(signed char what) {
        insert(_frac, what);
    }

    // insert digit to back of mantissa
    void mpush_back(signed char what) {
        insert(_len, what);
    }

    // remove digit from front of mantissas
    void mpop_back() {
        if ( mant() ) {
            (*this)[--_len] = 0;
        }
    }

    // insert digit to front of fraction
    void fpush_front(signed char what) {
        insert(0, what);
        _frac++;
    }

    // insert digit to back of fraction
    void fpush_back(signed char what) {
        insert(_frac++, what);
    }

public:
    static bigly ONE;
    static bigly ZERO;
};
} // end namespace cflib