/*
 * big_number - library for arbitrarily large numbers
 *
 * Copyright (C) 2023 Garyl Hester. All rights reserved.
 * 
 * This project lives at https://github.com/codefool/big_number
 *
 */
#pragma once

#include <iostream>
#include <cstring>
#include <cctype>
#include <iterator>
#include <memory>
#include <string>
#include <vector>

#include "buildinfo.h"

namespace cflib {

class big_number {
public:
    enum sign_t : bool {
        POS = false,
        NEG = true
    };
    typedef signed char          digit_t;
    typedef std::vector<digit_t> buff_t;

private:
    sign_t s;  // sign - true negative, false positive
    size_t d;  // position of decimal point
    buff_t b;  // buffer with number

public:
    big_number();
    big_number(std::string num);
    big_number(const int64_t val);

    std::vector<digit_t>::iterator begin() { return b.begin(); }
    std::vector<digit_t>::iterator end() { return b.end(); }
    std::vector<digit_t>::reverse_iterator rbegin() { return b.rbegin(); }
    std::vector<digit_t>::reverse_iterator rend() { return b.rend(); }
    std::vector<digit_t>::const_iterator cbegin() const { return b.cbegin(); }
    std::vector<digit_t>::const_iterator cend() const { return b.cend(); }
    std::vector<digit_t>::const_reverse_iterator crbegin() const { return b.crbegin(); }
    std::vector<digit_t>::const_reverse_iterator crend() const { return b.crend(); }

    bool is_zero() {
        return b.size() == 0;
    }

    inline int sign() const {
        return s ? -1 : 1;
    }

    big_number abs() const {
        big_number ret(*this);
        ret.s = POS;
        return ret;
    }

    big_number negate() const {
        auto ret(*this);
        ret.s = (sign_t)(!s);
        return ret;
    }

    void set_sign(sign_t t) {
        s = t;
    }

    bool is_negative() const {
        return s;
    }

    bool is_positive() const {
        return !s;
    }

    inline const size_t magn() const {
        return b.size();
    }       

    // answer -1 if lhs < rhs, 0 if lhs == rhs, and 1 if lhs > rhs
    int compare(const big_number& rhs) const;

    inline bool operator==(const big_number& rhs) const {
        return compare(rhs) == 0;
    }

    inline bool operator<(const big_number& rhs) const {
        return compare(rhs) < 0;
    }

    inline bool operator<=(const big_number& rhs) const {
        return compare(rhs) <= 0;
    }

    inline bool operator>(const big_number& rhs) const {
        return compare(rhs) > 0;
    }

    inline bool operator>=(const big_number& rhs) const {
        return compare(rhs) >= 0;
    }

    inline digit_t& operator[](size_t index) {
        return b[index];
    }

    big_number& operator++();
    big_number operator++(int);
    big_number& operator--();
    big_number operator--(int);

    big_number operator+(const big_number& rhs) const;
    big_number& operator+=(const big_number& rhs);

    big_number operator-(const big_number& rhs) const;
    big_number& operator-=(const big_number& rhs);

    big_number operator*(const big_number& rhs) const;
    big_number& operator*=(const big_number&rhs);
    big_number operator^(const big_number& rhs) const;
    big_number& operator^=(const big_number&rhs);

    big_number operator%(const big_number& rhs) const;
    big_number& operator%=(const big_number& rhs);
    big_number operator/(const big_number& rhs) const;
    big_number& operator/=(const big_number& rhs);

    big_number add(const big_number& rhs) const;
    big_number sub_method_one(const big_number&rhs) const;
    big_number sub_method_two(const big_number& rhs) const;
    big_number sub_method_diff_magn(const big_number& rhs) const;
    big_number nines_complement(const size_t len) const;
    big_number int_division(const big_number& rhs, big_number& rem) const;

    big_number& strip_leading(digit_t dig = 0);

    friend std::ostream& operator<<(std::ostream& os, const big_number& obj);

    static big_number factorial(size_t n);
    static big_number fibonacci(size_t n);

private:
    void append(const digit_t digit);
    void prepend(const digit_t digit);
    void truncate(size_t cnt);
    void reverse();

public:
    static big_number ONE;
    static big_number ZERO;
};
} // end namespace cflib