#pragma once

#include <iostream>
#include <cstring>
#include <cctype>
#include <memory>

#include "buildinfo.h"

class big_number {
public:
    const size_t B_SIZE = 2048;
    typedef signed char digit_t;

private:
    bool                           s;  // true negative, false positive
    short                          d;  // significant digits
    std::unique_ptr<digit_t[]> b;

public:
    big_number() 
    : s(false), d(0)
    {
        b = std::make_unique<digit_t[]>(B_SIZE);
        std::memset(b.get(), 0x00, B_SIZE);
    }

    big_number(const big_number& other)
    : big_number()
    {
        std::memcpy((void *)get(), (const void *)other.c_get(), other.size());
        d = other.d;
        s = other.s;
    }

    // accept a string of digits in canonical form
    // e.g. 1234567890
    // - leading zeros are ignored (removed)
    // - the remaining digits are the significant digit count
    // - the number is then loaded into the buffer LSD first
    big_number(std::string num) 
    : big_number()
    {
        auto itr = num.begin();
        for( ; itr != num.end() && (std::isspace(*itr) || *itr == '0'); ++itr)
            ;
        if ( itr == num.end() )
            return;
        // check for leading sign - if first char is '-' or '+' then set s accordingly
        bool signFound = false;
        if (*itr == '-' || *itr == '+') {
            s = *itr++ == '-';
            signFound = true;
        }
        auto p = b.get();
        while ( itr != num.end() && std::isdigit(*itr)) {
            *p++ = *itr++ - '0';
            d++;
        }
        // check for trailing sign - if next char is '-' or '+' then set s accordingly
        if (itr != num.end() && !signFound && (*itr == '-' || *itr == '+')) {
            s = *itr == '-';
        }
        auto q = b.get();
        while( p-- > q ) {
            auto t = *p;
            *p   = *q;
            *q++ = t;
        }
    }

    int sign() const {
        return s ? -1 : 1;
    }

    const size_t size() const {
        return d;
    }       

    const digit_t *c_get() const {
        return b.get();
    }

    // answer -1 if lhs < rhs, 0 if lhs == rhs, and 1 if lhs > rhs
    int compare(const big_number& rhs) const {
        // lhs has more signifant digits, or lhs positive and rhs negative
        if ( d > rhs.d || (!s && rhs.s)) return 1;
        // rhs has more signifant digits, or lhs negative and rhs positive
        if ( d < rhs.d || (s && !rhs.s)) return -1;
        // lhs and rhs have same sign and number of signifiant digits
        const digit_t *l = c_get() + d - 1;
        const digit_t *r = rhs.c_get() + d - 1;
        for( auto digit = d; digit; l--, r--, digit-- ) {
            if ( *l != *r ) {
                int diff = *l - *r;
                if ( s )        // if negative
                    diff *= -1; // flip sign
                return diff;
            }
        }
        return 0;
    }

    bool operator==(const big_number& rhs) const {
        return compare(rhs) == 0;
    }

    bool operator<(const big_number& rhs) const {
        return compare(rhs) < 0;
    }

    bool operator<=(const big_number& rhs) const {
        return compare(rhs) <= 0;
    }

    bool operator>(const big_number& rhs) const {
        return compare(rhs) > 0;
    }

    bool operator>=(const big_number& rhs) const {
        return compare(rhs) >= 0;
    }

    digit_t& operator[](size_t index) {
        return b[index];
    }

    big_number operator+(const big_number& rhs) const;

    big_number operator-(const big_number& rhs) const;

    big_number nines_complement() const;

    friend std::ostream& operator<<(std::ostream& os, big_number& obj);

private:
    digit_t *get() {
        return b.get();
    }    
};
