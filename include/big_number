#pragma once

#include <iostream>
#include <cstring>
#include <cctype>
#include <memory>

#include "buildinfo.h"

class big_number {
public:
    enum sign_t : bool {
        POS = false,
        NEG = true
    };
    static const size_t B_SIZE = 2048;
    typedef signed char digit_t;
    typedef digit_t buff_t[B_SIZE];
    typedef size_t      magnitude_t;

private:
    sign_t                  s;  // true negative, false positive
    magnitude_t             m;  // maginitude
    std::shared_ptr<buff_t> b;

public:
    big_number();
    big_number(const big_number& other);
    big_number(std::string num);

    bool is_zero() {
        return *this == ZERO;
    }

    inline int sign() const {
        return s ? -1 : 1;
    }

    big_number abs() const {
        big_number ret(*this);
        ret.s = POS;
        return ret;
    }

    big_number negate() const {
        auto ret(*this);
        ret.s = (sign_t)(!s);
        return ret;
    }

    void set_sign(sign_t t) {
        s = t;
    }

    bool is_negative() const {
        return s;
    }

    bool is_positive() const {
        return !s;
    }

    inline const size_t magn() const {
        return m;
    }       

    inline const digit_t *c_get() const {
        return b.get();
    }

    inline const digit_t *c_get_msd() const {
        return b.get() + m - 1;
    }

    // answer -1 if lhs < rhs, 0 if lhs == rhs, and 1 if lhs > rhs
    int compare(const big_number& rhs) const;

    inline bool operator==(const big_number& rhs) const {
        return compare(rhs) == 0;
    }

    inline bool operator<(const big_number& rhs) const {
        return compare(rhs) < 0;
    }

    inline bool operator<=(const big_number& rhs) const {
        return compare(rhs) <= 0;
    }

    inline bool operator>(const big_number& rhs) const {
        return compare(rhs) > 0;
    }

    inline bool operator>=(const big_number& rhs) const {
        return compare(rhs) >= 0;
    }

    inline digit_t& operator[](size_t index) {
        return b[index];
    }

    void operator=(const int64_t val);

    big_number& operator++();
    big_number operator++(int);
    big_number& operator--();
    big_number operator--(int);

    big_number operator+(const big_number& rhs) const;
    big_number& operator+=(const big_number& rhs);

    big_number operator-(const big_number& rhs) const;
    big_number& operator-=(const big_number& rhs);

    big_number operator*(const big_number& rhs) const;
    big_number& operator*=(const big_number&rhs);
    big_number operator^(const big_number& rhs) const;
    big_number& operator^=(const big_number&rhs);

    big_number operator%(const big_number& rhs) const;
    big_number& operator%=(const big_number& rhs);
    big_number operator/(const big_number& rhs) const;
    big_number& operator/=(const big_number& rhs);

    big_number add(const big_number& rhs) const;
    big_number sub_method_one(const big_number&rhs) const;
    big_number sub_method_two(const big_number& rhs) const;
    big_number sub_method_diff_magn(const big_number& rhs) const;
    big_number nines_complement(const size_t len) const;
    big_number int_division(const big_number& rhs, big_number& rem) const;

    big_number& strip_leading(digit_t dig = 0);

    friend std::ostream& operator<<(std::ostream& os, big_number& obj);

private:
    void append(const digit_t digit);
    void prepend(const digit_t digit);
    void reverse();

    inline digit_t *get() {
        return b.get();
    }
public:
    static big_number ONE;
    static big_number ZERO;
};
